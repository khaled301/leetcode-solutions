## Leet Code 347: Top K Frequent Elements

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

Example 1:

```plaintext
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

Example 2:
```plaintext
Input: nums = [1], k = 1
Output: [1]
```

Constraints:

```plaintext
1 <= nums.length <= 105
-104 <= nums[i] <= 104
k is in the range [1, the number of unique elements in the array].
It is guaranteed that the answer is unique.
```

Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.

## Breakdown of the Solution:

### Initialize Data Structures

**heap**: 
A list that will be used as a priority queue to store elements based on their frequencies. Python’s heapq module provides a min-heap, so we'll store negative frequencies to simulate a max-heap.

**record**: 
A dictionary to count the frequency of each element in the nums list.

### Count Frequencies
Iterate through each number `n` in `nums` and update its frequency in the `record` dictionary. If `n` is not already in `record`,  returns 0, so `record[n]` becomes 1. If `n` is already in `record`, it increments its count by `1`.

### Build the Heap
Iterate through the `record` dictionary and push each element into the heap. The `heapq.heappush` function adds elements to the heap and maintains the heap property. 
By storing `-val` (negative frequency), we simulate a `max-heap` behavior using `Python’s min-heap`. 
The heap will prioritize elements with higher frequencies because of the negative sign.

### Extract Top K Frequent Elements


**result**: 
Initialize an empty list to store the top k frequent elements.

**heapq.heappop(heap)**: 
Pop the smallest element from the `heap` (which is the one with the `highest frequency` due to the `negative sign`). The `[1]` retrieves the actual element (not its frequency) from the tuple `(-val, key)`.
while `len(result) < k` Continue extracting elements from the heap until we have `k` elements in `result`.


**Return result**: Once the loop completes and res contains the top k frequent elements, return res.


## Time Complexity:
- Building the frequency dictionary: O(n)

- Building the heap: O(u log u)

- Extracting the top k elements: O(k log u)

- Since the number of unique elements u is at most n:

- The overall time complexity is O(n + u log u + k log u). Considering u can be at most n, this simplifies to `O(n log n)`.

## Space Complexity:
- The space complexity is dominated by the frequency dictionary and the heap, both of which take O(u) space.

- Hence, the overall space complexity is O(u), which in the worst case simplifies to O(n) since u can be at most n.

## Complexity Summary:
- Time Complexity: O(n log n)

- Space Complexity: O(n)
