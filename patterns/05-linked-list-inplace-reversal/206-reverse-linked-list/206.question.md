## Leet Code 287: Find The Duplicate Number

Given the head of a singly linked list, reverse the list, and return the reversed list.


Example 1:

```plaintext
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

Example 2:
```plaintext
Input: head = [1,2]
Output: [2,1]
```

Example 3:
```plaintext
Input: head = []
Output: []
```

Constraints:

```plaintext
The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000
```

Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

## Breakdown of the Solution:

**Base Case Check**: 
If the list is empty (head is None) or has only one node (head.next is None), return the head as is.

**Initialization**:

prev is set to None (to mark the end of the reversed list).
curr is set to the head (to traverse the list).

**Reversal Loop**:

- Save the next node (next = curr.next) to not lose the reference.
- Reverse the link (curr.next = prev).
- Move prev to the current node (prev = curr) and curr to the next node (curr = next).

**Return**: 

When the loop finishes (curr becomes None), prev is the new head of the reversed list.

**Time Complexity**:

O(n): Each node is visited exactly once.

**Space Complexity**:

O(1): Only a constant amount of extra space is used (pointers prev, curr, and next).